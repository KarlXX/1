> L1 := proc (y, x) diff(y, `$`(x, 2))+y end proc;
> f := -x;
> phi := proc (n, x) if n = 0 then 0 else x^n*(1-x) end if end proc;
> 
> 
> 
> 
> Galerkin:=proc(L::procedure,f::algebraic,phi::procedure,x::name,a::numeric,b::numeric,n::numeric) 
local y,i,eq,A; y:=phi(0,x) + sum(A[i]*phi(i,x),i=1..n); 
for i to n do eql|i:=sum(A[k]*int(L(phi(k,x),x)*phi(i,x),x=a..b); end do; 
eq:=solve({seq(eql|i,i=1..n)},{seq(A[i],i = 1..n)}); 
assign(eq);
simplify(eval(y)); 
end proc:


